Index: src/main.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use std::env;\r\nuse std::process::exit;\r\nmod error;\r\nmod ast;\r\nmod interpreter;\r\npub(crate) mod tools;\r\nmod parse;\r\n\r\nuse ast::expr::*;\r\nuse crate::ast::token::object::Object;\r\nuse crate::ast::token::token::Token;\r\nuse crate::ast::token::token_type::Token_type;\r\nuse tools::println;\r\nfn main() {\r\n    let mut args = env::args();\r\n    //获取命令行参数\r\n    // println!(\"{}\",args.nth(1).unwrap());\r\n    let expr=Expr::Binary {\r\n        operator: Token::new(Token_type::MINUS, \"-\".to_string(), None, 0),\r\n        l_expression: Box::new(Expr::Literal {val:Some(Object::num(1.0))}),\r\n        r_expression: Box::new(Expr::Literal {val:Some(Object::num(2.0))}),\r\n    };\r\n    println(&expr);\r\n    if args.len()>2{\r\n     error::log(0, 0, \"X 是个脚本,参数传错啦\");\r\n        exit(64);\r\n    }else if args.len()==2{\r\n        //第一个是系统传入 第二个才是\r\n        //interpreter file\r\n        interpreter::run::run_file(args.nth(1).unwrap());\r\n    }else{\r\n        //interpreter prompt\r\n        error::log(0, 0, \"暂不支持命令行\");\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main.rs b/src/main.rs
--- a/src/main.rs	(revision ef6ee1f5f1672d8022921da9d332a29234989dbf)
+++ b/src/main.rs	(date 1730163457557)
@@ -1,34 +1,39 @@
 use std::env;
 use std::process::exit;
-mod error;
 mod ast;
+mod error;
 mod interpreter;
+mod parse;
 pub(crate) mod tools;
-mod parse;
 
-use ast::expr::*;
 use crate::ast::token::object::Object;
 use crate::ast::token::token::Token;
 use crate::ast::token::token_type::Token_type;
+use ast::expr::*;
 use tools::println;
 fn main() {
+    let expr = Expr::Binary {
+        operator: Token::new(Token_type::MINUS, "-".to_string(), None, 0),
+        l_expression: Box::new(Expr::Literal {
+            val: Some(Object::num(1.0)),
+        }),
+        r_expression: Box::new(Expr::Literal {
+            val: Some(Object::num(2.0)),
+        }),
+    };
     let mut args = env::args();
     //获取命令行参数
     // println!("{}",args.nth(1).unwrap());
-    let expr=Expr::Binary {
-        operator: Token::new(Token_type::MINUS, "-".to_string(), None, 0),
-        l_expression: Box::new(Expr::Literal {val:Some(Object::num(1.0))}),
-        r_expression: Box::new(Expr::Literal {val:Some(Object::num(2.0))}),
-    };
+
     println(&expr);
-    if args.len()>2{
-     error::log(0, 0, "X 是个脚本,参数传错啦");
+    if args.len() > 2 {
+        error::log(0, 0, "X 是个脚本,参数传错啦");
         exit(64);
-    }else if args.len()==2{
+    } else if args.len() == 2 {
         //第一个是系统传入 第二个才是
         //interpreter file
         interpreter::run::run_file(args.nth(1).unwrap());
-    }else{
+    } else {
         //interpreter prompt
         error::log(0, 0, "暂不支持命令行");
     }
Index: src/parse/parser.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::ast::expr::Expr;\r\nuse crate::ast::token::token::Token;\r\nuse crate::ast::token::token_type::Token_type;\r\n\r\npub(crate) struct Parser{\r\n    tokens: Vec<Token>,\r\n    pos:usize\r\n}\r\nimpl Parser{\r\n    fn new(tokens:Vec<Token>)->Self{\r\n        Self{tokens,pos:0}\r\n    }\r\n    fn expression(&self)->Expr{\r\n        self.equality()\r\n    }\r\n    fn equality(&self)->Expr{\r\n\r\n    }\r\n    fn advance(&mut self)->&Token{\r\n        if !self.is_end(){\r\n            self.pos += 1;\r\n        }\r\n         self.previous()\r\n    }\r\n    fn check(&self,token_type:Token_type)->bool{\r\n        if self.is_end(){\r\n              false\r\n        }else {\r\n            (*self.peek()).token_type == token_type\r\n        }\r\n    }\r\n\r\n    fn fulfill(&mut self, types:Vec<Token_type>) ->bool{\r\n        for t in types{\r\n         if  self.check(t){\r\n             self.advance();\r\n            return true;\r\n         }\r\n        }\r\n          false\r\n    }\r\n    fn is_end(&self)->bool{\r\n        (*self.previous()).token_type==Token_type::EOF\r\n    }\r\n    //当前token\r\n    fn peek(&self)->&Token{\r\n        &self.tokens[self.pos]\r\n    }\r\n    //前一个token\r\n    fn previous(&self)->&Token{\r\n        &self.tokens[self.pos - 1]\r\n    }\r\n\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/parse/parser.rs b/src/parse/parser.rs
--- a/src/parse/parser.rs	(revision ef6ee1f5f1672d8022921da9d332a29234989dbf)
+++ b/src/parse/parser.rs	(date 1730099910022)
@@ -31,6 +31,7 @@
     }
 
     fn fulfill(&mut self, types:Vec<Token_type>) ->bool{
+        //当前的token 必须是需要的 才能继续
         for t in types{
          if  self.check(t){
              self.advance();
